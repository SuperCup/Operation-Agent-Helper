# 纯前端实现方案

## 一、可行性评估

### 1.1 总体评估

**结论：完全可行** ✅

所有功能都可以在前端实现，但需要注意以下限制和优化点。

### 1.2 各功能可行性分析

| 功能 | 可行性 | 技术方案 | 限制/注意事项 |
|------|--------|----------|---------------|
| Agent API调用 | ✅ 完全可行 | 直接调用第三方AI API | API密钥安全、CORS问题 |
| 工作流执行引擎 | ✅ 完全可行 | 前端状态机 + Zustand | 复杂逻辑可能性能受限 |
| 文件上传处理 | ✅ 完全可行 | File API + IndexedDB | 存储空间限制（约5-10GB） |
| 文档生成服务 | ✅ 完全可行 | 纯前端库（pptxgenjs/xlsx/docx） | 大文件可能较慢 |
| 意图识别Agent | ✅ 完全可行 | 直接调用LLM API | API调用成本 |

### 1.3 主要挑战与解决方案

#### 挑战1：API密钥安全
**问题**：前端代码中暴露API密钥不安全  
**解决方案**：
- 方案A：使用环境变量（.env文件，不提交到Git）
- 方案B：使用代理服务（通过Vercel/Netlify Functions）
- 方案C：使用浏览器扩展存储（用户自行配置）

#### 挑战2：CORS跨域问题
**问题**：直接调用第三方API可能被CORS阻止  
**解决方案**：
- 方案A：使用代理（Vercel/Netlify Functions）
- 方案B：使用支持CORS的API服务
- 方案C：浏览器扩展（绕过CORS）

#### 挑战3：数据持久化
**问题**：localStorage有大小限制（约5-10MB）  
**解决方案**：
- 使用IndexedDB（约5-10GB）
- 数据压缩
- 定期清理旧数据

#### 挑战4：性能
**问题**：复杂工作流和文档生成可能较慢  
**解决方案**：
- Web Worker处理耗时任务
- 异步处理
- 进度反馈

---

## 二、详细实现方案

### 2.1 Agent API调用（前端实现）

#### 2.1.1 架构设计

```
┌─────────────────────────────────────────┐
│         前端应用                          │
│  ┌───────────────────────────────────┐  │
│  │  AgentService                     │  │
│  │  - API调用封装                     │  │
│  │  - 错误处理                        │  │
│  │  - 重试机制                        │  │
│  └──────────────┬────────────────────┘  │
│                 │                        │
│  ┌──────────────▼────────────────────┐  │
│  │  API Proxy (可选)                 │  │
│  │  - Vercel Functions               │  │
│  │  - Netlify Functions              │  │
│  └──────────────┬────────────────────┘  │
└─────────────────┼────────────────────────┘
                  │
┌─────────────────▼────────────────────────┐
│      第三方AI API                        │
│  - DeepSeek API                         │
│  - 其他LLM API（兼容OpenAI格式）        │
└─────────────────────────────────────────┘
```

#### 2.1.2 技术方案

**直接调用方案（推荐用于开发）**
```typescript
// src/services/agentService.ts
import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: import.meta.env.VITE_DEEPSEEK_API_KEY, // 环境变量
  baseURL: import.meta.env.VITE_DEEPSEEK_API_BASE_URL || 'https://api.deepseek.com',
  dangerouslyAllowBrowser: true, // 允许浏览器调用
});
```

**代理方案（推荐用于生产）**
```typescript
// 通过Vercel/Netlify Functions代理
const response = await fetch('/api/proxy/deepseek', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ message, ... }),
});
```

#### 2.1.3 实现代码

**文件：`src/services/agentService.ts`**

```typescript
import OpenAI from 'openai';
import { AgentMessage, IntentType } from '@/types';

class AgentService {
  private openai: OpenAI | null = null;
  private useProxy: boolean;

  constructor() {
    // 检查是否使用代理
    this.useProxy = import.meta.env.VITE_USE_API_PROXY === 'true';
    
    // 如果不使用代理，直接初始化DeepSeek客户端
    if (!this.useProxy && import.meta.env.VITE_DEEPSEEK_API_KEY) {
      this.openai = new OpenAI({
        apiKey: import.meta.env.VITE_DEEPSEEK_API_KEY,
        baseURL: import.meta.env.VITE_DEEPSEEK_API_BASE_URL || 'https://api.deepseek.com',
        dangerouslyAllowBrowser: true,
      });
    }
  }

  // 意图识别
  async recognizeIntent(
    message: string,
    context?: { history?: AgentMessage[] }
  ): Promise<{
    intent: IntentType | null;
    confidence: number;
    summary: string;
    reasoning?: string;
  }> {
    const prompt = this.buildIntentRecognitionPrompt(message, context);

    if (this.useProxy) {
      return this.callViaProxy('/api/intent/recognize', { message, context });
    }

    // 直接调用DeepSeek
    const response = await this.openai!.chat.completions.create({
      model: 'deepseek-chat',
      messages: [
        {
          role: 'system',
          content: prompt,
        },
        {
          role: 'user',
          content: message,
        },
      ],
      temperature: 0.3,
      response_format: { type: 'json_object' },
    });

    return JSON.parse(response.choices[0].message.content || '{}');
  }

  // Agent执行
  async executeAgent(
    agentId: string,
    taskId: string,
    params: Record<string, any>
  ): Promise<{
    taskId: string;
    workflowId: string;
    status: string;
  }> {
    // 实现Agent执行逻辑
    // ...
  }

  // 通过代理调用
  private async callViaProxy(endpoint: string, data: any) {
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data),
    });
    return response.json();
  }

  // 构建意图识别Prompt
  private buildIntentRecognitionPrompt(
    message: string,
    context?: { history?: AgentMessage[] }
  ): string {
    return `你是一个意图识别专家。请分析用户的输入，识别用户的意图。

可用的意图类型：
1. operation_plan - 运营方案生成
2. budget_split - 预算拆分
3. activity_config - 活动配置
4. activity_ops - 活动运营
5. rtb_plan - RTB方案
6. rtb_config - RTB配置
7. rtb_ops - RTB运营

${context?.history ? `对话历史：${JSON.stringify(context.history)}` : ''}

用户输入：${message}

请以JSON格式返回：
{
  "intent": "意图类型或null",
  "confidence": 0.0-1.0,
  "summary": "用户意图摘要",
  "reasoning": "识别理由"
}`;
  }
}

export const agentService = new AgentService();
```

#### 2.1.4 环境变量配置

**文件：`.env.local`**（不提交到Git）
```env
VITE_DEEPSEEK_API_KEY=sk-xxx
VITE_DEEPSEEK_API_BASE_URL=https://api.deepseek.com
VITE_USE_API_PROXY=false
VITE_PROXY_BASE_URL=https://your-app.vercel.app
```

#### 2.1.5 代理函数（可选，用于生产环境）

**文件：`api/proxy/deepseek.ts`**（Vercel Functions）
```typescript
export default async function handler(req: Request) {
  const { message, ...params } = await req.json();
  
  const response = await fetch('https://api.deepseek.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.DEEPSEEK_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'deepseek-chat',
      messages: [{ role: 'user', content: message }],
      ...params,
    }),
  });
  
  return response.json();
}
```

---

### 2.2 工作流执行引擎（前端实现）

#### 2.2.1 架构设计

```
┌─────────────────────────────────────────┐
│      前端工作流引擎                       │
│  ┌───────────────────────────────────┐  │
│  │  WorkflowEngine                   │  │
│  │  - 步骤编排                         │  │
│  │  - 状态管理                         │  │
│  │  - 执行控制                         │  │
│  └──────────────┬────────────────────┘  │
│                 │                        │
│  ┌──────────────▼────────────────────┐  │
│  │  StepExecutor (Web Worker)         │  │
│  │  - Agent调用                       │  │
│  │  - 工具执行                         │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

#### 2.2.2 实现代码

**文件：`src/services/workflowEngine.ts`**

```typescript
import { WorkflowTemplate, WorkflowStep, StepStatus } from '@/types';
import { agentService } from './agentService';

interface WorkflowExecution {
  id: string;
  templateId: string;
  taskId: string;
  status: 'idle' | 'running' | 'paused' | 'completed' | 'failed';
  currentStepId?: string;
  steps: WorkflowStepExecution[];
  context: Record<string, any>;
  createdAt: Date;
  updatedAt: Date;
}

interface WorkflowStepExecution {
  id: string;
  stepTemplateId: string;
  status: StepStatus;
  progress: number;
  input?: any;
  output?: any;
  error?: string;
  thinking?: string;
  logs: string[];
  startTime?: Date;
  endTime?: Date;
}

class WorkflowEngine {
  private executions: Map<string, WorkflowExecution> = new Map();
  private listeners: Map<string, Set<(execution: WorkflowExecution) => void>> = new Map();

  // 启动工作流
  async startWorkflow(
    template: WorkflowTemplate,
    taskId: string,
    initialParams: Record<string, any>
  ): Promise<string> {
    const executionId = `wf-${Date.now()}`;
    
    const execution: WorkflowExecution = {
      id: executionId,
      templateId: template.id,
      taskId,
      status: 'running',
      steps: template.steps.map((stepTemplate) => ({
        id: `step-${Date.now()}-${stepTemplate.id}`,
        stepTemplateId: stepTemplate.id,
        status: 'pending' as StepStatus,
        progress: 0,
        logs: [],
      })),
      context: initialParams,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    this.executions.set(executionId, execution);
    this.persistExecution(execution);

    // 异步执行
    this.executeWorkflow(executionId).catch((error) => {
      console.error('Workflow execution failed:', error);
      this.updateExecution(executionId, {
        status: 'failed',
        steps: execution.steps.map((s) =>
          s.id === execution.currentStepId
            ? { ...s, status: 'failed' as StepStatus, error: error.message }
            : s
        ),
      });
    });

    return executionId;
  }

  // 执行工作流
  private async executeWorkflow(executionId: string) {
    const execution = this.executions.get(executionId);
    if (!execution) return;

    const template = await this.getTemplate(execution.templateId);
    if (!template) throw new Error('Template not found');

    // 顺序执行步骤
    for (let i = 0; i < template.steps.length; i++) {
      const stepTemplate = template.steps[i];
      const step = execution.steps[i];

      if (execution.status === 'paused') {
        break;
      }

      // 更新当前步骤
      this.updateExecution(executionId, {
        currentStepId: step.id,
        steps: execution.steps.map((s) =>
          s.id === step.id
            ? { ...s, status: 'running' as StepStatus, startTime: new Date() }
            : s
        ),
      });

      try {
        // 执行步骤
        const result = await this.executeStep(stepTemplate, execution.context);

        // 更新步骤结果
        this.updateExecution(executionId, {
          steps: execution.steps.map((s) =>
            s.id === step.id
              ? {
                  ...s,
                  status: 'success' as StepStatus,
                  progress: 100,
                  output: result.output,
                  thinking: result.thinking,
                  logs: result.logs,
                  endTime: new Date(),
                }
              : s
          ),
          context: { ...execution.context, ...result.context },
        });

        // 如果需要人工确认，暂停
        if (stepTemplate.requiresHumanInput) {
          this.updateExecution(executionId, {
            status: 'paused',
            steps: execution.steps.map((s) =>
              s.id === step.id
                ? { ...s, status: 'waiting_human' as StepStatus }
                : s
            ),
          });
          break;
        }
      } catch (error: any) {
        // 步骤失败
        this.updateExecution(executionId, {
          steps: execution.steps.map((s) =>
            s.id === step.id
              ? {
                  ...s,
                  status: 'failed' as StepStatus,
                  error: error.message,
                  endTime: new Date(),
                }
              : s
          ),
          status: 'failed',
        });
        throw error;
      }
    }

    // 所有步骤完成
    if (execution.status !== 'paused' && execution.status !== 'failed') {
      this.updateExecution(executionId, { status: 'completed' });
    }
  }

  // 执行单个步骤
  private async executeStep(
    stepTemplate: any,
    context: Record<string, any>
  ): Promise<{
    output: any;
    thinking?: string;
    logs: string[];
    context: Record<string, any>;
  }> {
    const logs: string[] = [];
    logs.push(`开始执行: ${stepTemplate.name}`);

    // 根据步骤类型执行
    switch (stepTemplate.type) {
      case 'analysis':
        return await this.executeAnalysisStep(stepTemplate, context, logs);
      case 'generation':
        return await this.executeGenerationStep(stepTemplate, context, logs);
      case 'validation':
        return await this.executeValidationStep(stepTemplate, context, logs);
      default:
        throw new Error(`Unknown step type: ${stepTemplate.type}`);
    }
  }

  // 执行分析步骤
  private async executeAnalysisStep(
    stepTemplate: any,
    context: Record<string, any>,
    logs: string[]
  ) {
    // 调用Agent进行分析
    const result = await agentService.executeAgent(
      stepTemplate.agentConfig || '',
      context.taskId || '',
      context
    );

    logs.push('分析完成');
    return {
      output: result,
      thinking: result.thinking,
      logs,
      context: { ...context, analysis: result },
    };
  }

  // 执行生成步骤
  private async executeGenerationStep(
    stepTemplate: any,
    context: Record<string, any>,
    logs: string[]
  ) {
    // 调用Agent进行生成
    const result = await agentService.executeAgent(
      stepTemplate.agentConfig || '',
      context.taskId || '',
      context
    );

    logs.push('生成完成');
    return {
      output: result,
      thinking: result.thinking,
      logs,
      context: { ...context, generated: result },
    };
  }

  // 执行验证步骤
  private async executeValidationStep(
    stepTemplate: any,
    context: Record<string, any>,
    logs: string[]
  ) {
    // 验证逻辑
    logs.push('等待人工验证');
    return {
      output: null,
      logs,
      context,
    };
  }

  // 更新执行状态
  private updateExecution(
    executionId: string,
    updates: Partial<WorkflowExecution>
  ) {
    const execution = this.executions.get(executionId);
    if (!execution) return;

    const updated = {
      ...execution,
      ...updates,
      updatedAt: new Date(),
    };

    this.executions.set(executionId, updated);
    this.persistExecution(updated);
    this.notifyListeners(executionId, updated);
  }

  // 持久化到IndexedDB
  private async persistExecution(execution: WorkflowExecution) {
    // 使用IndexedDB存储
    const db = await this.getDB();
    const tx = db.transaction('workflows', 'readwrite');
    await tx.store.put(execution);
  }

  // 从IndexedDB恢复
  async restoreExecution(executionId: string): Promise<WorkflowExecution | null> {
    const db = await this.getDB();
    const tx = db.transaction('workflows', 'readonly');
    return await tx.store.get(executionId);
  }

  // 获取IndexedDB实例
  private async getDB(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('WorkflowDB', 1);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        if (!db.objectStoreNames.contains('workflows')) {
          db.createObjectStore('workflows', { keyPath: 'id' });
        }
      };
    });
  }

  // 订阅执行更新
  onExecutionUpdate(
    executionId: string,
    callback: (execution: WorkflowExecution) => void
  ) {
    if (!this.listeners.has(executionId)) {
      this.listeners.set(executionId, new Set());
    }
    this.listeners.get(executionId)!.add(callback);
  }

  // 通知监听器
  private notifyListeners(executionId: string, execution: WorkflowExecution) {
    const listeners = this.listeners.get(executionId);
    if (listeners) {
      listeners.forEach((callback) => callback(execution));
    }
  }

  // 获取模板（从store）
  private async getTemplate(templateId: string): Promise<WorkflowTemplate | null> {
    // 从zustand store获取
    const { workflowTemplates } = await import('@/store/useStore');
    return workflowTemplates.find((t) => t.id === templateId) || null;
  }

  // 暂停工作流
  pauseWorkflow(executionId: string) {
    this.updateExecution(executionId, { status: 'paused' });
  }

  // 恢复工作流
  resumeWorkflow(executionId: string) {
    const execution = this.executions.get(executionId);
    if (execution && execution.status === 'paused') {
      this.updateExecution(executionId, { status: 'running' });
      this.executeWorkflow(executionId);
    }
  }

  // 取消工作流
  cancelWorkflow(executionId: string) {
    this.updateExecution(executionId, { status: 'failed' });
  }
}

export const workflowEngine = new WorkflowEngine();
```

---

### 2.3 文件上传处理（前端实现）

#### 2.3.1 技术方案

使用IndexedDB存储文件，支持：
- 文件上传和存储
- 文件预览
- 文件管理（列表、删除）

#### 2.3.2 实现代码

**文件：`src/services/fileService.ts`**

```typescript
interface StoredFile {
  id: string;
  name: string;
  type: string;
  size: number;
  data: Blob;
  url?: string;
  previewUrl?: string;
  uploadedAt: Date;
  sessionId?: string;
  taskId?: string;
}

class FileService {
  private dbName = 'FileDB';
  private dbVersion = 1;
  private storeName = 'files';

  // 初始化数据库
  private async getDB(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => resolve(request.result);
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
          store.createIndex('sessionId', 'sessionId', { unique: false });
          store.createIndex('taskId', 'taskId', { unique: false });
        }
      };
    });
  }

  // 上传文件
  async uploadFile(
    file: File,
    options?: { sessionId?: string; taskId?: string; type?: string }
  ): Promise<StoredFile> {
    const fileId = `file-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    // 读取文件为Blob
    const blob = await file.arrayBuffer();
    
    const storedFile: StoredFile = {
      id: fileId,
      name: file.name,
      type: file.type,
      size: file.size,
      data: new Blob([blob], { type: file.type }),
      uploadedAt: new Date(),
      sessionId: options?.sessionId,
      taskId: options?.taskId,
    };

    // 生成预览URL（如果是图片）
    if (file.type.startsWith('image/')) {
      storedFile.previewUrl = URL.createObjectURL(storedFile.data);
    }

    // 存储到IndexedDB
    const db = await this.getDB();
    const tx = db.transaction(this.storeName, 'readwrite');
    await tx.store.put(storedFile);
    await tx.done;

    return storedFile;
  }

  // 获取文件
  async getFile(fileId: string): Promise<StoredFile | null> {
    const db = await this.getDB();
    const tx = db.transaction(this.storeName, 'readonly');
    return await tx.store.get(fileId);
  }

  // 获取文件列表
  async getFiles(options?: {
    sessionId?: string;
    taskId?: string;
  }): Promise<StoredFile[]> {
    const db = await this.getDB();
    const tx = db.transaction(this.storeName, 'readonly');
    const store = tx.store;

    if (options?.sessionId) {
      const index = store.index('sessionId');
      return await index.getAll(options.sessionId);
    }

    if (options?.taskId) {
      const index = store.index('taskId');
      return await index.getAll(options.taskId);
    }

    return await store.getAll();
  }

  // 删除文件
  async deleteFile(fileId: string): Promise<void> {
    const file = await this.getFile(fileId);
    if (file?.previewUrl) {
      URL.revokeObjectURL(file.previewUrl);
    }

    const db = await this.getDB();
    const tx = db.transaction(this.storeName, 'readwrite');
    await tx.store.delete(fileId);
    await tx.done;
  }

  // 获取文件URL（用于下载/预览）
  async getFileURL(fileId: string): Promise<string> {
    const file = await this.getFile(fileId);
    if (!file) throw new Error('File not found');

    if (file.url) {
      return file.url;
    }

    // 生成临时URL
    const url = URL.createObjectURL(file.data);
    return url;
  }

  // 预览文件（图片/PDF）
  async previewFile(fileId: string): Promise<string> {
    const file = await this.getFile(fileId);
    if (!file) throw new Error('File not found');

    if (file.previewUrl) {
      return file.previewUrl;
    }

    if (file.type.startsWith('image/')) {
      const url = URL.createObjectURL(file.data);
      return url;
    }

    if (file.type === 'application/pdf') {
      const url = URL.createObjectURL(file.data);
      return url;
    }

    throw new Error('File type not supported for preview');
  }

  // 下载文件
  async downloadFile(fileId: string, filename?: string): Promise<void> {
    const file = await this.getFile(fileId);
    if (!file) throw new Error('File not found');

    const url = await this.getFileURL(fileId);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename || file.name;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // 清理临时URL
    setTimeout(() => URL.revokeObjectURL(url), 100);
  }

  // 获取存储使用情况
  async getStorageUsage(): Promise<{ used: number; quota: number }> {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      const estimate = await navigator.storage.estimate();
      return {
        used: estimate.usage || 0,
        quota: estimate.quota || 0,
      };
    }
    return { used: 0, quota: 0 };
  }

  // 清理旧文件
  async cleanupOldFiles(daysOld: number = 30): Promise<number> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);

    const db = await this.getDB();
    const tx = db.transaction(this.storeName, 'readwrite');
    const store = tx.store;
    const cursor = await store.openCursor();
    let deletedCount = 0;

    while (cursor) {
      const file = cursor.value as StoredFile;
      if (file.uploadedAt < cutoffDate) {
        await cursor.delete();
        deletedCount++;
      }
      if (!(await cursor.continue())) break;
    }

    await tx.done;
    return deletedCount;
  }
}

export const fileService = new FileService();
```

---

### 2.4 文档生成服务（前端实现）

#### 2.4.1 技术方案

使用纯前端库：
- **PPT生成**：`pptxgenjs`
- **Excel生成**：`xlsx` 或 `exceljs`
- **Doc生成**：`docx`

#### 2.4.2 实现代码

**文件：`src/services/documentService.ts`**

```typescript
import PptxGenJS from 'pptxgenjs';
import * as XLSX from 'xlsx';
import { Document, Packer, Paragraph, TextRun } from 'docx';

interface DocumentGenerationOptions {
  type: 'ppt' | 'excel' | 'doc';
  data: Record<string, any>;
  template?: string;
  style?: Record<string, any>;
}

class DocumentService {
  // 生成PPT
  async generatePPT(
    data: Record<string, any>,
    options?: { template?: string }
  ): Promise<Blob> {
    const pptx = new PptxGenJS();

    // 添加标题页
    const slide = pptx.addSlide();
    slide.addText(data.title || '运营方案', {
      x: 1,
      y: 1,
      w: 8,
      h: 1,
      fontSize: 32,
      bold: true,
      align: 'center',
    });

    // 添加内容页
    if (data.sections) {
      data.sections.forEach((section: any, index: number) => {
        const contentSlide = pptx.addSlide();
        contentSlide.addText(section.title, {
          x: 0.5,
          y: 0.5,
          w: 9,
          h: 0.5,
          fontSize: 24,
          bold: true,
        });
        contentSlide.addText(section.content, {
          x: 0.5,
          y: 1.5,
          w: 9,
          h: 4,
          fontSize: 14,
        });
      });
    }

    // 生成Blob
    const blob = await pptx.write({ outputType: 'blob' });
    return blob;
  }

  // 生成Excel
  async generateExcel(
    data: Record<string, any>,
    options?: { template?: string }
  ): Promise<Blob> {
    const workbook = XLSX.utils.book_new();

    // 如果有多个工作表
    if (data.sheets) {
      data.sheets.forEach((sheet: any) => {
        const worksheet = XLSX.utils.aoa_to_sheet(sheet.data);
        XLSX.utils.book_append_sheet(workbook, worksheet, sheet.name);
      });
    } else {
      // 单个工作表
      const worksheet = XLSX.utils.json_to_sheet(data.rows || []);
      XLSX.utils.book_append_sheet(workbook, worksheet, 'Sheet1');
    }

    // 生成Blob
    const blob = XLSX.write(workbook, {
      type: 'blob',
      bookType: 'xlsx',
    });

    return blob;
  }

  // 生成Doc
  async generateDoc(
    data: Record<string, any>,
    options?: { template?: string }
  ): Promise<Blob> {
    const doc = new Document({
      sections: [
        {
          properties: {},
          children: [
            // 标题
            new Paragraph({
              children: [
                new TextRun({
                  text: data.title || '运营方案',
                  bold: true,
                  size: 32,
                }),
              ],
              spacing: { after: 400 },
            }),
            // 内容
            ...(data.content || []).map(
              (paragraph: string) =>
                new Paragraph({
                  children: [
                    new TextRun({
                      text: paragraph,
                      size: 24,
                    }),
                  ],
                  spacing: { after: 200 },
                })
            ),
          ],
        },
      ],
    });

    // 生成Blob
    const blob = await Packer.toBlob(doc);
    return blob;
  }

  // 统一生成接口
  async generateDocument(options: DocumentGenerationOptions): Promise<{
    blob: Blob;
    url: string;
    size: number;
  }> {
    let blob: Blob;

    switch (options.type) {
      case 'ppt':
        blob = await this.generatePPT(options.data, options);
        break;
      case 'excel':
        blob = await this.generateExcel(options.data, options);
        break;
      case 'doc':
        blob = await this.generateDoc(options.data, options);
        break;
      default:
        throw new Error(`Unsupported document type: ${options.type}`);
    }

    // 生成URL
    const url = URL.createObjectURL(blob);

    return {
      blob,
      url,
      size: blob.size,
    };
  }

  // 下载文档
  async downloadDocument(
    blob: Blob,
    filename: string
  ): Promise<void> {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    setTimeout(() => URL.revokeObjectURL(url), 100);
  }
}

export const documentService = new DocumentService();
```

#### 2.4.3 安装依赖

```bash
npm install pptxgenjs xlsx docx file-saver
```

---

### 2.5 意图识别Agent（前端实现）

已在2.1节中实现，使用AgentService的`recognizeIntent`方法。

---

## 三、集成到现有代码

### 3.1 更新EnhancedAIChatBox

```typescript
// 替换模拟的意图识别
import { agentService } from '@/services/agentService';

const intentResult = await agentService.recognizeIntent(message, {
  history: currentSession?.messages,
});
```

### 3.2 更新工作流执行

```typescript
// 使用工作流引擎
import { workflowEngine } from '@/services/workflowEngine';

const workflowId = await workflowEngine.startWorkflow(
  workflowTemplate,
  taskId,
  params
);
```

### 3.3 更新文件上传

```typescript
// 使用文件服务
import { fileService } from '@/services/fileService';

const storedFile = await fileService.uploadFile(file, {
  sessionId: currentSession?.id,
  taskId: currentTask?.id,
});
```

### 3.4 更新文档生成

```typescript
// 使用文档服务
import { documentService } from '@/services/documentService';

const result = await documentService.generateDocument({
  type: 'ppt',
  data: taskOutput,
});
```

---

## 四、环境配置

### 4.1 环境变量

**文件：`.env.local`**
```env
# DeepSeek API配置
VITE_DEEPSEEK_API_KEY=sk-xxx
VITE_DEEPSEEK_API_BASE_URL=https://api.deepseek.com
VITE_USE_API_PROXY=false

# 代理配置（如果使用）
VITE_PROXY_BASE_URL=https://your-app.vercel.app
```

### 4.2 安装依赖

```bash
# AI API客户端
npm install openai  # DeepSeek兼容OpenAI SDK格式

# 文档生成
npm install pptxgenjs xlsx docx file-saver

# 类型定义
npm install -D @types/xlsx
```

---

## 五、实施计划

### 阶段一：基础服务层（3-5天）
1. 创建AgentService（API调用）
2. 创建FileService（文件管理）
3. 创建DocumentService（文档生成）
4. 环境变量配置

### 阶段二：工作流引擎（5-7天）
1. 实现WorkflowEngine核心逻辑
2. 实现步骤执行器
3. IndexedDB持久化
4. 状态管理集成

### 阶段三：集成测试（2-3天）
1. 集成到EnhancedAIChatBox
2. 集成到QuickActionsBar
3. 端到端测试
4. 错误处理优化

### 阶段四：优化与完善（2-3天）
1. 性能优化（Web Worker）
2. 错误处理完善
3. 用户体验优化
4. 文档完善

**总计：12-18天**

---

## 六、注意事项

### 6.1 API密钥安全
- ✅ 使用环境变量，不提交到Git
- ✅ 生产环境使用代理
- ⚠️ 提醒用户自行配置API密钥

### 6.2 存储限制
- IndexedDB限制：约5-10GB（取决于浏览器）
- 需要实现存储清理机制
- 大文件考虑压缩

### 6.3 性能优化
- 使用Web Worker处理耗时任务
- 大文件分片处理
- 异步执行，避免阻塞UI

### 6.4 浏览器兼容性
- IndexedDB：现代浏览器支持
- File API：现代浏览器支持
- Web Worker：现代浏览器支持

---

## 七、总结

✅ **完全可行**：所有功能都可以在前端实现

**优势**：
- 无需后端服务器
- 部署简单（静态托管）
- 开发快速
- 成本低

**限制**：
- API密钥需要用户配置
- 存储空间有限
- 复杂逻辑可能性能受限

**建议**：
- 开发阶段：直接调用API
- 生产环境：使用代理保护API密钥
- 大文件：考虑使用对象存储

---

**文档版本**：v1.0  
**创建日期**：2026-01-28  
**最后更新**：2026-01-28
